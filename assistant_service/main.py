import logging
import os

import chainlit as cl
from openai import AsyncOpenAI
from processors import ThreadMessageProcessor

from assistant_service.config import build_engine_config
from commons.data_models.config import BaseConfig
from commons.repositories.secrets import GCPSecretRepository

logger = logging.getLogger("Assistant")
logging.basicConfig(level=os.environ.get("LOGLEVEL", "INFO"))

base_config = BaseConfig()  # Loads variables from the environment
secret_repository = GCPSecretRepository(
    project_id=base_config.project_id, client_id=base_config.client_id
)
engine_config = build_engine_config(secret_repository)

client = AsyncOpenAI(api_key=engine_config.openai_apikey)


@cl.on_chat_start
async def start_chat():
    thread = await client.beta.threads.create()
    logger.info(f"Created thread: {thread.id}")
    cl.user_session.set("thread", thread)
    await cl.Message(
        author="assistant",
        content="Ask me some meditation questions!",
        disable_feedback=True,
    ).send()


@cl.step(name="Assistant", type="run", root=True)
async def run(thread_id: str, human_query: str):
    # Add the message to the thread
    init_message = await client.beta.threads.messages.create(
        thread_id=thread_id, role="user", content=human_query
    )
    logging.info(f"Created message: {init_message.id}, content:{init_message.content}")

    # Create the run
    run = await client.beta.threads.runs.create(
        thread_id=thread_id, assistant_id=engine_config.assistant_id
    )
    logging.info(f"Created run: {run.id}")

    thread_processor = ThreadMessageProcessor()
    # While to periodically check for updates
    while True:
        # Retrieve the previously created run
        run = await client.beta.threads.runs.retrieve(thread_id=thread_id, run_id=run.id)
        logging.info(f"Retrieved run: {run.id}")

        # Retrieve the run steps
        run_steps = await client.beta.threads.runs.steps.list(
            thread_id=thread_id, run_id=run.id, order="asc"
        )

        for step in run_steps.data:
            logging.info(f"Step: {step.step_details}")
            # Fetch step details
            run_step = await client.beta.threads.runs.steps.retrieve(
                thread_id=thread_id, run_id=run.id, step_id=step.id
            )
            step_details = run_step.step_details

            if step_details.type == "message_creation":
                # Retrieve message generated by the model.
                thread_message = await client.beta.threads.messages.retrieve(
                    message_id=step_details.message_creation.message_id,
                    thread_id=thread_id,
                )
                processed_message = await thread_processor.process(thread_message)
                if thread_processor.send_message:
                    await processed_message.send()
                else:
                    await processed_message.update()

        await cl.sleep(2)  # Refresh every 2 seconds
        if run.status in ["cancelled", "failed", "completed", "expired"]:
            break


@cl.on_message
async def on_message(message_from_ui: cl.Message):
    thread = cl.user_session.get("thread")  # type: Thread
    await run(thread_id=thread.id, human_query=message_from_ui.content)
