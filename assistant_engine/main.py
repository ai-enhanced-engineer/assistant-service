import json
import logging
import os
from datetime import datetime
from typing import Any

import chainlit as cl
from config import build_engine_config
from functions import TOOL_MAP
from openai import AsyncOpenAI
from openai.types.beta.threads.runs import RunStep
from openai.types.beta.threads.runs.tool_calls_step_details import ToolCall
from processors import ThreadMessageProcessor

from botbrew_commons.data_models import BaseConfig
from botbrew_commons.repositories import GCPConfigRepository, GCPSecretRepository

logger = logging.getLogger("assistant-engine")
logging.basicConfig(level=os.environ.get("LOGLEVEL", "INFO"))

base_config = BaseConfig()  # Loads variables from the environment
secret_repository = GCPSecretRepository(project_id=base_config.project_id, client_id=base_config.client_id)
config_repository = GCPConfigRepository(
    client_id=base_config.client_id, project_id=base_config.project_id, bucket_name=base_config.bucket_id
)
engine_config = build_engine_config(secret_repository, config_repository)

client = AsyncOpenAI(api_key=engine_config.openai_apikey)


@cl.on_chat_start
async def start_chat():
    thread = await client.beta.threads.create()
    logger.info(f"Created thread: {thread.id}")
    cl.user_session.set("thread", thread)
    await cl.Message(
        author="assistant",
        content="Ask me some questions!",
        disable_feedback=True,
    ).send()


class DictToObject:
    def __init__(self, dictionary):
        for key, value in dictionary.items():
            if isinstance(value, dict):
                setattr(self, key, DictToObject(value))
            else:
                setattr(self, key, value)

    def __str__(self):
        return "\n".join(f"{key}: {value}" for key, value in self.__dict__.items())


async def process_tool_call(
        step_references: dict[str, cl.Step],
        step: RunStep,
        tool_call: ToolCall,
        name: str,
        input: Any,
        output: Any,
        show_input: str = None,
):
    logger.info(f"DEBUG: Step references: {step_references}")
    cl_step = None
    update = False
    if tool_call.id not in step_references:
        cl_step = cl.Step(
            name=name,
            type="tool",
            parent_id=cl.context.current_step.id,
            show_input=show_input,
        )
        step_references[tool_call.id] = cl_step

    else:
        update = True
        cl_step = step_references[tool_call.id]

    if step.created_at:
        cl_step.start = datetime.fromtimestamp(step.created_at).isoformat()
    if step.completed_at:
        cl_step.end = datetime.fromtimestamp(step.completed_at).isoformat()

    cl_step.input = input
    cl_step.output = output

    if update:
        await cl_step.update()
    else:
        await cl_step.send()


@cl.step(name="Assistant", type="run", root=True)
async def run(thread_id: str, human_query: str):
    # Add the message to the thread
    init_message = await client.beta.threads.messages.create(thread_id=thread_id, role="user", content=human_query)
    logging.info(f"Created message: {init_message.id}, content:{init_message.content}")

    # Create the run
    run = await client.beta.threads.runs.create(thread_id=thread_id, assistant_id=engine_config.assistant_id)
    logging.info(f"Created run: {run.id}")

    thread_processor = ThreadMessageProcessor(client=client)
    step_references = {}  # type: dict[str, cl.Step]
    tool_outputs = []
    # While to periodically check for updates
    while True:
        # Retrieve the previously created run
        run = await client.beta.threads.runs.retrieve(thread_id=thread_id, run_id=run.id)
        logging.info(f"Retrieved run: {run.id}")

        # Retrieve the run steps
        run_steps = await client.beta.threads.runs.steps.list(thread_id=thread_id, run_id=run.id, order="asc")

        for step in run_steps.data:
            logging.info(f"Step: {step.step_details}")
            # Fetch step details
            run_step = await client.beta.threads.runs.steps.retrieve(
                thread_id=thread_id, run_id=run.id, step_id=step.id
            )
            step_details = run_step.step_details

            if step_details.type == "message_creation":
                # Retrieve message generated by the model.
                thread_message = await client.beta.threads.messages.retrieve(
                    message_id=step_details.message_creation.message_id,
                    thread_id=thread_id,
                )
                processed_message = await thread_processor.process(thread_message)
                if thread_processor.send_message:
                    await processed_message.send()
                else:
                    await processed_message.update()

            if step_details.type == "tool_calls":
                for tool_call in step_details.tool_calls:
                    if isinstance(tool_call, dict):
                        tool_call = DictToObject(tool_call)

                    if tool_call.type == "code_interpreter":
                        await process_tool_call(
                            step_references=step_references,
                            step=step,
                            tool_call=tool_call,
                            name=tool_call.type,
                            input=tool_call.code_interpreter.input or "# Generating code",
                            output=tool_call.code_interpreter.outputs,
                            show_input="python",
                        )

                        tool_outputs.append(
                            {
                                "output": tool_call.code_interpreter.outputs or "",
                                "tool_call_id": tool_call.id,
                            }
                        )

                    elif tool_call.type == "retrieval":
                        logger.info(f"Processing tool: {tool_call.type}")
                        await process_tool_call(
                            step_references=step_references,
                            step=step,
                            tool_call=tool_call,
                            name=tool_call.type,
                            input="Retrieving information",
                            output="Retrieved information",
                        )

                    elif tool_call.type == "function":
                        function_name = tool_call.function.name
                        function_args = json.loads(tool_call.function.arguments)

                        function_output = TOOL_MAP[function_name](**json.loads(tool_call.function.arguments))

                        await process_tool_call(
                            step_references=step_references,
                            step=step,
                            tool_call=tool_call,
                            name=function_name,
                            input=function_args,
                            output=function_output,
                            show_input="json",
                        )

                        tool_outputs.append({"output": function_output, "tool_call_id": tool_call.id})

            if run.status == "requires_action" and run.required_action.type == "submit_tool_outputs":
                await client.beta.threads.runs.submit_tool_outputs(
                    thread_id=thread_id,
                    run_id=run.id,
                    tool_outputs=tool_outputs,
                )

        await cl.sleep(2)  # Refresh every 2 seconds
        if run.status in ["cancelled", "failed", "completed", "expired"]:
            break


@cl.on_message
async def on_message(message_from_ui: cl.Message):
    thread = cl.user_session.get("thread")  # type: Thread
    await run(thread_id=thread.id, human_query=message_from_ui.content)
